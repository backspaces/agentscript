<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: AgentArray.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: AgentArray.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import util from './util.js'

// An Array superclass with convenience methods used by NetLogo.
// Tipically the items in the array are Objects, NetLogo Agents,
// but generally useful as an ArrayPlus

/**
 * Subclass of Array used by AgentScript, enspired by NetLogo
 * @class
 * @extends Array
 */
class AgentArray extends Array {
    /**
     * Convert an existing Array to an AgentArray "in place".
     * Use array.slice() if a new array is wanted
     *
     * @static
     * @param {Array} array Array to convert to AgentArray
     * @return {AgentArray}
     * @memberof AgentArray
     */
    static fromArray(array) {
        Object.setPrototypeOf(array, AgentArray.prototype)
        return array
    }

    // /**
    //  * Creates an instance of AgentArray. Simply calls super()
    //  *
    //  * @memberof AgentArray
    //  */
    // constructor() {
    //     super()
    // }

    /**
     * Convert this AgentArray to Array in-place
     *
     * @return {Array} This AgentArray converted to Array
     * @memberof AgentArray
     */
    toArray() {
        Object.setPrototypeOf(this, Array.prototype)
        return this
    }

    // NL: Return true if reporter true for all of this set's objects
    // Use Array.every(). Also Array.some()
    // all (reporter) { return this.every(reporter) }
    // // Return !isEmpty()
    // any () { return this.length !== 0 }
    // NL: Return AgentArray with reporter(agent) true. Use Array.filter()
    // with (reporter) { return this.filter(reporter) }

    /**
     * Return true if there are no items in this Array
     *
     * @return {boolean}
     * @memberof AgentArray
     */
    isEmpty() {
        return this.length === 0
    }
    /**
     * Return first item in this array. Returns undefined if empty.
     *
     * @return {any}
     * @memberof AgentArray
     */
    first() {
        return this[0]
    }
    /**
     * Return last item in this array. Returns undefined if empty.
     *
     * @return {any}
     * @memberof AgentArray
     */
    last() {
        return this[this.length - 1]
    }

    /**
     * Return true if fcn(element) returns true for each element in array.
     * Same as Array.every, using NetLogo's name
     *
     * @param {Function} fcn Return boolean
     * @return {boolean} true if fcn returns true for all elements
     * @memberof AgentArray
     */
    all(fcn) {
        return this.every(fcn)
    }

    /**
     * Return array of property values from this array's objects.
     * Array type is specified, defaults to AgentArray
     *
     * @param {String} key Property name
     * @param {ArrayType} [type=AgentArray]
     * @return {Array} Array of given type
     * @memberof AgentArray
     */
    props(key, type = AgentArray) {
        const result = new type(this.length)
        for (let i = 0; i &lt; this.length; i++) {
            result[i] = this[i][key]
        }
        return result
    }
    // Creates an OofA for several sets of props.
    // Obj is key, arrayType pairs: x: Float32Array
    // Result is this.props(key, arrayType) for each key
    /**
     * Creates an Object of Arrays, one Array per property.
     * Obj is key, arrayType pairs: x: Float32Array
     *
     * @param {Object} obj Object of prop, array type pairs
     * @return {Object}
     * @memberof AgentArray
     */
    typedSample(obj) {
        // const length = this.length
        const result = {}
        // note: use util's forLoop, does not iterate over this agent array.
        util.forLoop(obj, (val, key) => {
            result[key] = this.props(key, val)
        })
        return result
    }

    // Return AgentArray of results of the function fcn
    // Similar to "props" but can return computation over all keys
    // Odd: as.props('type') twice as fast as as.results(p => p.type)?
    // results(fcn) {
    //     const result = new AgentArray(this.length)
    //     for (let i = 0; i &lt; this.length; i++) {
    //         result[i] = fcn(this[i])
    //     }
    //     return result
    // }

    /**
     * Return new AgentArray of the unique values of this array
     *
     * @return {AgentArray}
     * @memberof AgentArray
     */
    uniq() {
        // return AgentArray.fromArray(Array.from(new Set(this)))
        return AgentArray.from(new Set(this))
    }

    // Returns AgentArray of unique elements in this *sorted* AgentArray.
    // Use sortBy or clone &amp; sortBy if needed.
    // uniq(f = util.identityFcn) {
    //     if (util.isString(f)) f = o => o[f]
    //     return this.filter((ai, i, a) => i === 0 || f(ai) !== f(a[i - 1]))
    // }

    // Call fcn(agent, index, array) for each agent in AgentArray.
    // Array assumed not mutable
    // Note: 5x+ faster than this.forEach(fcn) !!
    /**
     * Call fcn(agent, index, array) for each item in AgentArray.
     * Index &amp; array optional.
     * Array assumed not mutable.
     * Note: 5x+ faster than this.forEach(fcn)
     *
     * @param {Function} fcn fcn(agent, index?, array?)
     * @memberof AgentArray
     * @return {this} Return this for chaining.
     */
    forLoop(fcn) {
        for (let i = 0, len = this.length; i &lt; len; i++) {
            fcn(this[i], i, this)
        }
        return this
    }

    // Call fcn(agent, index, array) for each item in AgentArray.
    // Array can shrink. If it grows, will not visit beyond original length
    /**
     * Call fcn(agent, index, array) for each item in AgentArray.
     * Index &amp; array optional.
     * Array can shrink. If it grows, will not visit beyond original length.
     * "ask" is NetLogo term.
     *
     * @param {Function} fcn fcn(agent, index?, array?)
     * @memberof AgentArray
     */
    ask(fcn) {
        const length = this.length
        // for (let i = 0; i &lt; length || i &lt; this.length; i++) {
        for (let i = 0; i &lt; Math.min(length, this.length); i++) {
            fcn(this[i], i, this)
        }
        if (length != this.length) {
            const name = this.name || this.constructor.name
            const direction = this.length &lt; length ? 'decreasing' : 'increasing'
            util.warn(`AgentArray.ask array mutation: ${name}: ${direction}`)
        }
        // return this
    }
    // Return all elements returning f(obj, index, array) true
    /**
     * Return all elements returning f(obj, index, array) true.
     * NetLogo term, simply calls this.filter(fcn)
     *
     * @param {Function} fcn fcn(agent, index?, array?)
     * @return {AgentArray}
     * @memberof AgentArray
     * @description
     * Use: turtles.with(t => t.foo > 20).ask(t => t.bar = true)
     */
    with(fcn) {
        return this.filter(fcn)
    }
    // Return all other than me.
    other(t) {
        return this.filter(o => o !== t)
    }

    // Return count of agents with reporter(agent) true
    count(reporter) {
        return this.reduce((prev, o) => prev + (reporter(o) ? 1 : 0), 0)
    }

    sum(key) {
        return this.reduce((prev, o) => prev + (key ? o[key] : o), 0)
    }
    avg(key) {
        return this.sum(key) / this.length
    }
    min(key) {
        return this.reduce((prev, o) => Math.min(prev, key ? o[key] : o))
    }
    max(key) {
        return this.reduce((prev, o) => Math.max(prev, key ? o[key] : o))
    }
    extent(key) {
        return [this.min(key), this.max(key)]
    }
    histogram(key, bins = 10, min = this.min(key), max = this.max(key)) {
        const binSize = (max - min) / bins
        const aa = new AgentArray(bins)
        aa.fill(0)
        this.ask(a => {
            const val = key ? a[key] : a
            if (val &lt; min || val > max) {
                util.warn(`histogram bounds error: ${val}: ${min}-${max}`)
            } else {
                let bin = Math.floor((val - min) / binSize)
                if (bin === bins) bin-- // val is max, round down
                aa[bin]++
            }
        })
        // Object.assign(aa, {bins, min, max, binSize, key})
        aa.parameters = { key, bins, min, max, binSize, arraySize: this.length }
        // console.log(key, bins, min, max, binSize, aa)
        return aa
    }

    // Return shallow copy of a portion of this AgentArray
    // [See Array.slice](https://goo.gl/Ilgsok)
    // Default is to clone entire AgentArray
    cloneRange(begin = 0, end = this.length) {
        return this.slice(begin, end) // Returns an AgentArray rather than Array!
    }
    clone() {
        return this.slice(0) // Returns an AgentArray rather than Array!
    }
    // Randomize the AgentArray in place. Use clone first if new AgentArray needed.
    // Return "this" for chaining.
    shuffle() {
        return util.shuffle(this)
    }
    // Return this AgentArray sorted by the reporter in ascending/descending order.
    // If reporter is a string, convert to a fcn returning that property.
    // Use clone if you don't want to mutate this array.
    sortBy(reporter, ascending = true) {
        util.sortObjs(this, reporter, ascending)
        return this
    }

    // Remove an item from an array. Binary search if f given
    // Array unchanged if item not found.
    remove(o, f) {
        const i = this.agentIndex(o, f)
        if (i !== -1) this.splice(i, 1)
        else util.warn(`remove: ${o} not in AgentArray`)
        return this // chaining
    }
    insert(o, f) {
        const i = this.sortedIndex(o, f)
        if (this[i] === o) throw Error('insert: item already in AgentArray')
        this.splice(i, 0, o) // copyWithin?
    }

    // Binary search:
    // Return array index of item, where array is sorted.
    // If item not found, return index for item for array to remain sorted.
    // f is used to return an integer for sorting, defaults to identity.
    // If f is a string, it is the object property to sort by.
    // Adapted from underscore's _.sortedIndex.
    sortedIndex(item, f = util.identityFcn) {
        if (util.isString(f)) f = util.propFcn(f)
        const value = f(item)
        // Why not array.length - 1? Because we can insert 1 after end of array.
        // let [low, high] = [0, array.length]
        let low = 0
        let high = this.length
        while (low &lt; high) {
            const mid = (low + high) >>> 1 // floor (low+high)/2
            if (f(this[mid]) &lt; value) {
                low = mid + 1
            } else {
                high = mid
            }
        }
        return low
    }
    // Return index of value in array with given property or -1 if not found.
    // Binary search if property isnt null
    // Property can be string or function.
    // Use property = identity to compare objs directly.
    agentIndex(item, property) {
        if (!property) return this.indexOf(item)
        const i = this.sortedIndex(item, property)
        return this[i] === item ? i : -1
    }
    // True if item is in array. Binary search if f given
    contains(item, f) {
        return this.agentIndex(item, f) >= 0
    }

    // Return a random agent. Return undefined if empty.
    oneOf() {
        return util.oneOf(this)
    }
    // Return a random agent, not equal to agent
    otherOneOf(agent) {
        return util.otherOneOf(this, agent)
    }
    // Return n other random agents from this array
    // otherNOf (n, agent) { return util.otherNOf(n, this, agent) }
    otherNOf(n, item) {
        if (this.length &lt; n) throw Error('AgentArray: otherNOf: length &lt; N')
        return this.clone().remove(item).shuffle().slice(0, n)
    }

    // Return the first agent having the min/max of given value of f(agent).
    // If reporter is a string, convert to a fcn returning that property
    minOrMaxOf(min, reporter, valueToo = false) {
        if (this.isEmpty()) throw Error('min/max OneOf: empty array')
        if (typeof reporter === 'string') reporter = util.propFcn(reporter)
        let o = null
        let val = min ? Infinity : -Infinity
        for (let i = 0; i &lt; this.length; i++) {
            const a = this[i]
            const aval = reporter(a)
            if ((min &amp;&amp; aval &lt; val) || (!min &amp;&amp; aval > val)) {
                ;[o, val] = [a, aval]
            }
        }
        return valueToo ? [o, val] : o
    }
    // The min version of the above
    minOneOf(reporter) {
        return this.minOrMaxOf(true, reporter)
    }
    // The max version of the above
    maxOneOf(reporter) {
        return this.minOrMaxOf(false, reporter)
    }
    // Like the pair above, but return both the object and its value in an array.
    // const [obj, value] = minValOf(...)
    minValOf(reporter) {
        return this.minOrMaxOf(true, reporter, true)
    }
    maxValOf(reporter) {
        return this.minOrMaxOf(false, reporter, true)
    }

    // Return n random agents as AgentArray.
    // See [Fisher-Yates-Knuth shuffle](https://goo.gl/fWNFf)
    // for better approach for large n.
    nOf(n) {
        if (n > this.length) throw Error('nOf: n larger than AgentArray')
        if (n === this.length) return this
        const result = new AgentArray()
        while (result.length &lt; n) {
            const o = this.oneOf()
            if (!(o in result)) result.push(o)
        }
        return result
    }
    // Return a new AgentArray of the n min/max agents of the value of reporter,
    // in ascending order.
    // If reporter is a string, convert to a fcn returning that property
    // NOTE: we do not manage ties, see NetLogo docs.
    minOrMaxNOf(min, n, reporter) {
        if (n > this.length) {
            throw Error('min/max nOf: n larger than AgentArray')
        }
        const as = this.clone().sortBy(reporter)
        return min ? as.clone(0, n) : as.clone(as.length - n)
    }
    minNOf(n, reporter) {
        return this.minOrMaxNOf(true, n, reporter)
    }
    maxNOf(n, reporter) {
        return this.minOrMaxNOf(false, n, reporter)
    }

    // Geometry methods for patches, turtles, and other AgentArrays which have x,y.
    // Return all agents within rect, radius, cone from given agent o.
    // If meToo, include given object, default excludes it
    // Typically the AgentArray is a subset of larger sets, reducing
    // the size, then uses these inRect, inRadius or inCone methods

    // Return all agents within rectangle from given agent o.
    // dx &amp; dy are (float) half width/height of rect
    inRect(o, dx, dy = dx, meToo = false) {
        const agents = new AgentArray()
        const minX = o.x - dx // ok if max/min off-world, o, a are in-world
        const maxX = o.x + dx
        const minY = o.y - dy
        const maxY = o.y + dy
        this.ask(a => {
            if (minX &lt;= a.x &amp;&amp; a.x &lt;= maxX &amp;&amp; minY &lt;= a.y &amp;&amp; a.y &lt;= maxY) {
                if (meToo || o !== a) agents.push(a)
            }
        })
        return agents
    }

    // Return all agents in AgentArray within d distance from given object.
    inRadius(o, radius, meToo = false) {
        const agents = new AgentArray()
        // const {x, y} = o // perf?
        const d2 = radius * radius
        const sqDistance = util.sqDistance // Local function 2-3x faster, inlined?
        this.ask(a => {
            if (sqDistance(o.x, o.y, a.x, a.y) &lt;= d2) {
                if (meToo || o !== a) agents.push(a)
            }
        })
        return agents
    }

    // As above, but also limited to the angle `coneAngle` around
    // a `angle` from object `o`.
    inCone(o, radius, coneAngle, angle, meToo = false) {
        const agents = new AgentArray()
        this.ask(a => {
            if (util.inCone(a.x, a.y, radius, coneAngle, angle, o.x, o.y)) {
                if (meToo || o !== a) agents.push(a)
            }
        })
        return agents
    }
}

export default AgentArray
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AgentArray.html">AgentArray</a></li><li><a href="AgentSet.html">AgentSet</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Thu Oct 22 2020 11:16:35 GMT-0600 (Mountain Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
